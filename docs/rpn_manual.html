<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>现代 C++ 手把手实现 RPN 计算器</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
    <link rel="stylesheet" media="(prefers-color-scheme: dark)" 
          href="https://cdn.jsdelivr.net/gh/highlightjs/highlight.js/src/styles/night-owl.css">
    <link rel="stylesheet" media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)" 
          href="https://cdn.jsdelivr.net/gh/highlightjs/highlight.js/src/styles/atom-one-light.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <style>
        body {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2em;
            line-height: 1.6;
        }
        h1, h2, h3 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        pre {
            border: 1px solid #809eb7;
            border-radius: 4px 4px 0 0;
            margin-bottom: 0;
            overflow-x: auto;
        }
        pre code {
            border-radius: 4px 4px 0 0;
        }
        .code-block {
            margin: 1.5em 0;
        }
        .filename {
            background: #809eb7;
            color: white;
            padding: 0.5em 1em;
            border-radius: 4px 4px 0 0;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', Consolas, monospace;
            font-size: 0.9em;
        }
        .toc {
            background: #f8f9fa;
            padding: 1.5em;
            border-radius: 8px;
            margin: 2em 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 1em;
        }
        .toc li {
            margin: 0.5em 0;
        }
        .toc a {
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .meta {
            display: flex;
            gap: 2em;
            margin: 1em 0;
            color: #666;
            font-size: 0.9em;
        }
        .console {
            background: #1a1a1a;
            color: #00ff9d;
            padding: 1em;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            margin: 1em 0;
        }
        .console::before {
            content: "$ ";
        }
        .note {
            background: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 1em;
            margin: 1.5em 0;
            border-radius: 0 4px 4px 0;
        }
        .chapter {
            border-bottom: 1px solid #eee;
            padding-bottom: 2em;
            margin-bottom: 2em;
        }
        .chapter:last-child {
            border-bottom: none;
        }
        .highlight {
            background: #fff8e1;
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>现代 C++ 手把手实现 RPN 计算器</h1>
    
    <p><strong>从零开始实现一个完整的逆波兰表示法计算器</strong></p>
    
    <div class="meta">
        <span><strong>版本:</strong> 1.0</span>
        <span><strong>编译器:</strong> GCC 10+/Clang 12+/MSVC 2019+</span>
        <span><strong>标准:</strong> C++17</span>
    </div>
    
    <div class="toc">
        <h3>目录</h3>
        <ul>
            <li><a href="#chapter1">第 1 章: Hello RPN</a></li>
            <li><a href="#chapter2">第 2 章: 头文件化 + 单元测试</a></li>
            <li><a href="#chapter3">第 3 章: 交互式 REPL</a></li>
            <li><a href="#chapter4">第 4 章: 单文件发布 & 交叉编译</a></li>
            <li><a href="#chapter5">第 5 章: 扩展功能与挑战</a></li>
        </ul>
    </div>

    <div class="chapter" id="chapter1">
        <h2>第 1 章: Hello RPN</h2>
        
        <p>我们先从一个最小可运行的 RPN 计算器开始，理解逆波兰表示法的核心思想。</p>
        
        <div class="note">
            <p><strong>RPN 简介</strong></p>
            <p>逆波兰表示法（Reverse Polish Notation）是一种不需要括号的数学表达式表示法，所有运算符都跟在操作数后面。</p>
            <p>示例：<code>3 4 +</code> 表示 <code>3 + 4</code>，<code>3 4 + 5 *</code> 表示 <code>(3 + 4) * 5</code></p>
        </div>
        
        <div class="code-block">
            <div class="filename">rpn_min.cpp</div>
            <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

double rpn_evaluate(const std::string& expression) {
    std::stack&lt;double&gt; stack;
    std::istringstream iss(expression);
    std::string token;
    
    while (iss &gt;&gt; token) {
        if (token.size() == 1 && std::string("+-*/").find(token[0]) != std::string::npos) {
            if (stack.size() &lt; 2) {
                throw std::runtime_error("Error: insufficient operands");
            }
            
            double b = stack.top(); stack.pop();
            double a = stack.top(); stack.pop();
            
            switch (token[0]) {
                case '+': stack.push(a + b); break;
                case '-': stack.push(a - b); break;
                case '*': stack.push(a * b); break;
                case '/': 
                    if (b == 0) throw std::runtime_error("Error: division by zero");
                    stack.push(a / b); 
                    break;
            }
        } else {
            try {
                stack.push(std::stod(token));
            } catch (const std::invalid_argument&) {
                throw std::runtime_error("Error: invalid token '" + token + "'");
            }
        }
    }
    
    if (stack.size() != 1) {
        throw std::runtime_error("Error: expression invalid");
    }
    
    return stack.top();
}

int main() {
    std::string expression;
    std::cout &lt;&lt; "Enter RPN expression: ";
    std::getline(std::cin, expression);
    
    try {
        double result = rpn_evaluate(expression);
        std::cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
    } catch (const std::exception& e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return 1;
    }
    
    return 0;
}</code></pre>
        </div>
        
        <div class="console">g++ -std=c++17 -o rpn_min rpn_min.cpp && ./rpn_min</div>
        
        <div class="note">
            <p><strong>本章要点</strong></p>
            <ul>
                <li>理解 RPN 的基本原理</li>
                <li>使用 <code>std::stack</code> 实现计算</li>
                <li>基本的错误处理机制</li>
            </ul>
        </div>
    </div>

    <div class="chapter" id="chapter2">
        <h2>第 2 章: 头文件化 + 单元测试</h2>
        
        <p>将核心逻辑封装成头文件，并添加单元测试确保正确性。</p>
        
        <div class="code-block">
            <div class="filename">rpn_engine.hpp</div>
            <pre><code class="language-cpp">#pragma once

#include &lt;stack&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

class RPNEngine {
public:
    static double evaluate(const std::string& expression) {
        std::stack&lt;double&gt; stack;
        std::istringstream iss(expression);
        std::string token;
        
        while (iss &gt;&gt; token) {
            if (is_operator(token)) {
                if (stack.size() &lt; 2) {
                    throw std::runtime_error("Insufficient operands");
                }
                
                double b = stack.top(); stack.pop();
                double a = stack.top(); stack.pop();
                apply_operator(stack, token, a, b);
            } 
            else if (is_function(token)) {
                if (stack.empty()) {
                    throw std::runtime_error("No operand for function");
                }
                
                double a = stack.top(); stack.pop();
                apply_function(stack, token, a);
            }
            else {
                try {
                    stack.push(std::stod(token));
                } catch (const std::invalid_argument&) {
                    throw std::runtime_error("Invalid token: " + token);
                }
            }
        }
        
        if (stack.size() != 1) {
            throw std::runtime_error("Invalid expression");
        }
        
        return stack.top();
    }

private:
    static bool is_operator(const std::string& token) {
        if (token.size() != 1) return false;
        char op = token[0];
        return op == '+' || op == '-' || op == '*' || op == '/' || op == '^';
    }
    
    static bool is_function(const std::string& token) {
        return token == "sqrt" || token == "sin" || token == "cos" || token == "log";
    }
    
    static void apply_operator(std::stack&lt;double&gt;& stack, const std::string& op, 
                              double a, double b) {
        switch (op[0]) {
            case '+': stack.push(a + b); break;
            case '-': stack.push(a - b); break;
            case '*': stack.push(a * b); break;
            case '/': 
                if (b == 0) throw std::runtime_error("Division by zero");
                stack.push(a / b); 
                break;
            case '^': stack.push(std::pow(a, b)); break;
        }
    }
    
    static void apply_function(std::stack&lt;double&gt;& stack, const std::string& func, 
                              double a) {
        if (func == "sqrt") {
            if (a < 0) throw std::runtime_error("Square root of negative number");
            stack.push(std::sqrt(a));
        } else if (func == "sin") {
            stack.push(std::sin(a));
        } else if (func == "cos") {
            stack.push(std::cos(a));
        } else if (func == "log") {
            if (a <= 0) throw std::runtime_error("Logarithm of non-positive number");
            stack.push(std::log(a));
        }
    }
};</code></pre>
        </div>
    </div>

    <div class="chapter" id="chapter3">
        <h2>第 3 章: 交互式 REPL</h2>
        
        <p>实现一个完整的交互式计算器，支持历史记录和命令补全。</p>
        
        <div class="code-block">
            <div class="filename">repl.cpp</div>
            <pre><code class="language-cpp">#include "rpn_engine.hpp"
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

class REPL {
private:
    std::vector&lt;std::string&gt; history;
    
    void print_help() {
        std::cout &lt;&lt; "\n=== RPN Calculator Commands ===\n";
        std::cout &lt;&lt; "  &lt;expression&gt;    Evaluate RPN expression\n";
        std::cout &lt;&lt; "  help            Show this help message\n";
        std::cout &lt;&lt; "  history         Show calculation history\n";
        std::cout &lt;&lt; "  clear           Clear the screen\n";
        std::cout &lt;&lt; "  quit / exit     Exit the program\n";
        std::cout &lt;&lt; "\nOperators: + - * / ^\n";
        std::cout &lt;&lt; "Functions: sqrt sin cos log\n";
        std::cout &lt;&lt; "Example: '5 5 + 3 *' =&gt; 30\n";
        std::cout &lt;&lt; "==============================\n";
    }
    
    void print_history() {
        if (history.empty()) {
            std::cout &lt;&lt; "No history yet.\n";
            return;
        }
        
        std::cout &lt;&lt; "\n=== Calculation History ===\n";
        for (size_t i = 0; i &lt; history.size(); ++i) {
            std::cout &lt;&lt; i + 1 &lt;&lt; ". " &lt;&lt; history[i] &lt;&lt; "\n";
        }
        std::cout &lt;&lt; "===========================\n";
    }

public:
    void run() {
        std::cout &lt;&lt; "RPN Calculator REPL (Type 'help' for commands)\n";
        std::cout &lt;&lt; "==============================================\n\n";
        
        std::string line;
        while (true) {
            std::cout &lt;&lt; "rpn&gt; ";
            if (!std::getline(std::cin, line)) break;
            
            line.erase(0, line.find_first_not_of(" \t\n\r"));
            line.erase(line.find_last_not_of(" \t\n\r") + 1);
            
            if (line.empty()) continue;
            
            if (line == "quit" || line == "exit") {
                std::cout &lt;&lt; "Goodbye!\n";
                break;
            } else if (line == "help") {
                print_help();
                continue;
            } else if (line == "history") {
                print_history();
                continue;
            } else if (line == "clear") {
                for (int i = 0; i &lt; 50; ++i) std::cout &lt;&lt; "\n";
                continue;
            }
            
            try {
                double result = RPNEngine::evaluate(line);
                std::cout &lt;&lt; "= " &lt;&lt; std::setprecision(12) &lt;&lt; result &lt;&lt; "\n";
                history.push_back(line + " =&gt; " + std::to_string(result));
            } catch (const std::exception& e) {
                std::cout &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; "\n";
            }
        }
    }
};

int main() {
    REPL repl;
    repl.run();
    return 0;
}</code></pre>
        </div>
    </div>

    <div class="chapter" id="chapter4">
        <h2>第 4 章: 单文件发布 & 交叉编译</h2>
        
        <p>将整个项目打包成单个文件，并支持跨平台编译。</p>
        
        <table>
            <thead>
                <tr>
                    <th>平台</th>
                    <th>编译命令</th>
                    <th>文件大小</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Linux/macOS</td>
                    <td><code>g++ -std=c++17 -O3 -o rpn rpn_single.cpp</code></td>
                    <td>~92 KB</td>
                </tr>
                <tr>
                    <td>Windows (MinGW)</td>
                    <td><code>x86_64-w64-mingw32-g++ -std=c++17 -O3 -o rpn.exe rpn_single.cpp</code></td>
                    <td>~85 KB</td>
                </tr>
            </tbody>
        </table>
        
        <div class="console"># 下载完整项目
git clone https://github.com/sonya-lzy/rpn_calc.git
cd rpn_calc

# 编译并运行
g++ -std=c++17 -o rpn src/rpn_calc.cpp
./rpn</div>
    </div>

    <div class="chapter" id="chapter5">
        <h2>第 5 章: 扩展功能与挑战</h2>
        
        <div class="note">
            <p><strong>扩展挑战</strong></p>
            <ol>
                <li><span class="highlight">复数支持</span>：扩展支持复数运算</li>
                <li><span class="highlight">变量存储</span>：实现变量赋值和使用</li>
                <li><span class="highlight">脚本模式</span>：支持从文件读取表达式</li>
                <li><span class="highlight">图形界面</span>：使用 Qt 或 ImGUI 添加 GUI</li>
                <li><span class="highlight">网络计算</span>：实现客户端-服务器模式</li>
            </ol>
        </div>
        
        <p>
            <a href="https://github.com/sonya-lzy/rpn_calc">GitHub 仓库</a> |
            <a href="https://sonya-lzy.github.io/rpn_calc/">在线文档</a>
        </p>
    </div>

    <footer>
        <p>© 2024 RPN Calculator Project | C++ 编程作业</p>
    </footer>

    <script>
        // 初始化highlight.js
        hljs.highlightAll();
        
        // 自动为所有代码块添加复制按钮
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('pre code').forEach(function(block) {
                // 检查是否已经有复制按钮
                if (!block.parentNode.querySelector('.copy-btn')) {
                    var btn = document.createElement('button');
                    btn.className = 'copy-btn';
                    btn.textContent = '复制';
                    btn.style.cssText = 'position:absolute;right:10px;top:10px;padding:5px 10px;background:#809eb7;color:white;border:none;border-radius:3px;cursor:pointer;font-size:0.8em;';
                    btn.onclick = function() {
                        navigator.clipboard.writeText(block.textContent).then(function() {
                            btn.textContent = '已复制!';
                            setTimeout(function() {
                                btn.textContent = '复制';
                            }, 2000);
                        });
                    };
                    block.parentNode.style.position = 'relative';
                    block.parentNode.appendChild(btn);
                }
            });
        });
    </script>
</body>
</html>
HTML
